#' Calculate Country-wise Population-weighted HDD/CDD Values
#'
#' This function computes population-weighted Heating Degree Days (HDD) and Cooling Degree Days (CDD)
#' for individual countries, based on raw ambient temperature or bias-adjusted internal temperature.
#' Calculations are performed using raster data for various climate variables and specified limit temperatures.
#'
#' For further processing, raster objects containing degree day data are written for ten-year intervals.
#'
#' @param ftas Character string specifying the file name of data on near-surface atmospheric temperature.
#' @param tlim Named list of temperature limit sequences for \code{HDD} and \code{CDD}.
#' @param countries \code{SpatRaster} object defining the regional aggregation boundaries.
#' @param pop \code{SpatRaster} object containing population data.
#' @param factors Data frame containing degree day values for the combinations of \code{temp} and \code{tlim}.
#' @param bait Logical; if \code{TRUE}, BAIT is used as the ambient temperature.
#' @param frsds (Optional) Character string specifying the file name of data on
#' surface downdwelling shortwave radiation.
#' @param fsfc (Optional) Character string specifying the file name of data on near-surface wind speed.
#' @param fhuss (Optional) Character string specifying the file name of data on near-surface specific humidity.
#' @param wBAIT (Optional) Named list containing weights for BAIT.
#' @param baitPars (Optional) \code{SpatRaster} object containing regression parameters
#' generated by \code{calcBAITpars}.
#'
#' @return A data frame containing regional population-weighted annual degree days.
#'
#' @details
#' The function integrates various climate and population datasets to produce a regionalized summary of
#' HDD/CDD values. It supports optional adjustments based on additional climate variables and regression
#' parameters when using BAIT for internal temperature calculations.
#'
#' @author Hagen Tockhorn
#'
#' @importFrom raster writeRaster
#' @importFrom stringr str_split
#' @importFrom terra writeCDF round
#' @importFrom madrat readSource
#' @importFrom dplyr mutate
#' @importFrom magrittr %>%

compStackHDDCDD <- function(ftas, tlim, countries, pop, factors, bait,
                            frsds = NULL,
                            fsfc  = NULL,
                            fhuss = NULL,
                            wBAIT = NULL,
                            baitPars = NULL) {
  # read cellular temperature
  temp <- importData(subtype = ftas)

  dates <- names(temp)

  # optional: transform raw temperature into BAIT
  if (bait) {
    # note: easier to do in [C]
    tempCelsius <- temp - 273.15   # [C]

    # read and prepare bait input data
    baitInput <- prepBaitInput(frsds, fsfc, fhuss) %>%
      checkDates(tempCelsius)

    # calculate bait
    tempBAIT <- compBAIT(baitInput, tempCelsius, weight = wBAIT, params = baitPars)   # [C]

    # convert back to [K]
    temp <- tempBAIT + 273.15   # [K]
  }

  # round and assign dates
  temp <- terra::round(temp, digits = 1)
  names(temp) <- dates

  # loop: type of degree day
  hddcdd <- do.call(rbind, lapply(c("HDD", "CDD"), function(typeDD) {
    # loop: threshold temperatures
    do.call(rbind, lapply(tlim[[typeDD]], function(t) {
      compCellHDDCDD(temp, typeDD, t, factors) %>%
        aggCells(pop, countries) %>%
        mutate("variable" = typeDD,
               "tlim"     = t)    # [C]
    }))
  }))

  return(hddcdd)
}



#' Assign HDD/CDD values for given ambient/limit temperature
#'
#' @param temp SpatRaster containing temperature/BAIT values
#' @param typeDD type of degree day
#' @param tlim limit temperature
#' @param factors data frame with degree day values for \code{temp/tlim} combination
#'
#' @returns SpatRaster with HDD/CDD values
#'
#' @author Hagen Tockhorn
#'
#' @importFrom terra classify tapp time
#' @importFrom dplyr filter reframe .data
#' @importFrom magrittr %>%

compCellHDDCDD <- function(temp, typeDD, tlim, factors) {
  # extract years
  dates <- names(temp)

  # add tolerance of 0.049K to avoid machine precision errors
  factors <- factors[factors$typeDD == typeDD, ]

  factors <- factors %>%
    filter(.data[["tLim"]] == tlim) %>%
    dplyr::reframe(from =    .data[["T_amb_K"]] - 0.049,
                   to =      .data[["T_amb_K"]] + 0.049,
                   becomes = .data[["factor"]]) %>%
    data.matrix()

  # swap ambient temperature values with corresponding DD values
  hddcdd <- classify(temp, factors)

  terra::time(hddcdd) <- as.Date(dates)

  # aggregate to yearly HDD/CDD [K.d/a]
  hddcdd <- tapp(hddcdd, "years", fun = sum, na.rm = TRUE)

  names(hddcdd) <- gsub("y_", "", names(hddcdd))
  return(hddcdd)
}



#' Aggregate cellular HDD/CDD values to country-wide average (population-weighted)
#'
#' @param data SpatRaster object containing HDD/CDD values
#' @param weight SpatRaster object containing aggregation weights
#' @param mask SpatRaster object defining (regional) aggregation boundaries
#'
#' @return data frame containing regionally averaged HDD/CDD values
#'
#' @author Hagen Tockhorn
#'
#' @importFrom terra subset global

aggCells <- function(data, weight, mask) {
  message("Aggregating degree days to regions...")

  yearsData   <- names(data)
  yearsWeight <- names(weight)

  if (!all(yearsData %in% yearsWeight)) {
    stop("Time periods of raster file and aggregation weights do not match.")
  }

  # loop: years in raster file r
  hddcddAgg <- do.call(
    "rbind", lapply(
      yearsData, function(y) {
        # mask data and weights to considered regions
        regData   <- subset(data, y) * subset(weight, y) * mask
        regWeight <- subset(weight, y) * mask

        # aggregate regional data
        regDataAgg   <- terra::global(regData,   "sum", na.rm = TRUE)$sum
        regWeightAgg <- terra::global(regWeight, "sum", na.rm = TRUE)$sum

        # calculate weighted sum
        weightedAgg <- regDataAgg / regWeightAgg

        aggData <- data.frame("region" = names(mask),
                              "period" = y,
                              "value"  = round(weightedAgg, 3))

        rownames(aggData) <- c()
        return(aggData)
      }
    )
  )
  return(hddcddAgg)
}
